# HTTP 优化

## HTTP 1.1 的优化

#### 1. 缓存处理

- **HTTP1.0**中主要使用 **If-Modified-Since,Expires** 来做为缓存判断的标准
- **HTTP1.1**则引入了更多的缓存控制策略例如**Entity tag，If-Unmodified-Since, If-Match, If-None-Match**等更多可供选择的缓存头来控制缓存

#### 2. HTTP1.1 新增 **24** 个错误状态响应码

#### 3. 增加了 Request 方法，有**OPTIONS**, **PUT**, **DELETE**, **TRACE**, **CONNECT**

#### 4. 必须存在 Host 首部

- 在**HTTP1.0**中认为每台服务器都绑定一个唯一的IP地址，因此可以不添加 Host 头域，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址
- 为了区分，**HTTP1.1**的请求消息和响应消息都应支持**Host头域**，且请求消息中如果没有**Host**头域会报告一个错误（400 Bad Request）

#### 5. 带宽优化及网络连接的使用

- **HTTP1.0**中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了
- **HTTP1.1**则在请求头引入了**range**头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接

#### 6. `长连接`（keep-alive）

- 解决问题：每个资源都会进行一次 **TCP** 连接，这样会造成无谓的 **TCP** 连接建立（三次握手）和断开，增加通信量的开销
- 特点：只要任意一端没有明确提出断开连接，则保持 **TCP** 连接状态

#### 7. `管线化`（Pipelining）

- 建立在长连接的基础上

- 不用等待响应亦可直接发送下一个请求，则服务器可并行处理多个请求

  ![](https://gitee.com/kingmusi/imgs/raw/master/blog/20211108172845.png)

- 存在瓶颈：HTTP 1.x 只能严格串行地返回响应，即虽然 CSS 处理比 HTML 处理要快，但却依然要比 HTML 响应要慢，这种情况被称为**队首阻塞**

> HTTP 1.x 解决队首阻塞的权宜之计
>
> 使用多个 TCP 连接，每个客户端最多可以开启 6 个 TCP 连接

## HTTP 2.0 的优化

#### 1. 二进制分帧层

- 位于套接字接口与应用可见的高层 HTTP API 之间的一个新机制

- HTTP 1.x 以换行符作为纯文本的分隔符，而 HTTP 2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用**二进制**格式的编码

- 所有通信都在一个 TCP 连接上完成

- **流**是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（1、2…N）

- **消息**是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成

- **帧**是最小的通信单位，承载着特定类型的数据，如 HTTP 首部、负荷，等等

- 突破队首阻塞：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来

  ![](https://gitee.com/kingmusi/imgs/raw/master/blog/20211108175233.png)

#### 2. 流量控制

- 流量控制基于每一跳进行，而非端到端的控制
- 流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节
- 流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小
- 流量控制可以由接收方禁用，包括针对个别的流和针对整个连接

#### 3. 服务器推送

- 解析文档需要的资源，提前推送给客户端，让客户端缓存起来，从而减少时间延迟

#### 4. 首部压缩

- 在客户端和服务器端使用**首部表**来跟踪和存储之前发送的键－值对， 对于相同的数据，不再通过每次请求和响应发送
- 首部表在连接存续期内始终存在，由客户端和服务器共同渐进地更新
- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值

