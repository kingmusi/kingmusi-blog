# 逐帧动画

## 核心原理

逐帧动画是将一连串的连续动作的静态图片，合并成一张雪碧图，通过 CSS 改变背景图的位置（background-position），让画面从一帧跳动到下一帧

使用 `animation-timing-function` 的 **`step()`** 函数实现，它会将动画周期分割成 n 个等距的断点：

- **语法**：`steps(number_of_steps, direction)`
- **number_of_steps**：整数，表示将动画过程分为多少帧

## 雪碧图的逐帧动画

把 loading 动画所有帧合并到一张雪碧图

![](https://cdn.musiblog.com/CSS/%E5%8A%A8%E7%94%BB%E4%B8%8E%E8%BF%87%E6%B8%A1/%E9%80%90%E5%B8%A7%E5%8A%A8%E7%94%BB-loading.png)

第一种：通过 `background-position` 移动

:::demo

```html
<div></div>
```

```css
div {
  /* 设置为单帧的尺寸 */
  width: 100px;
  height: 100px;
  /* 引入雪碧图 */
  background-image: url('./逐帧动画-loading.png');
  background-repeat: no-repeat;
  /* 8步 */
  animation: move-strip 1s steps(8) infinite;
}

@keyframes move-strip {
  to {
    /* 雪碧图的总宽度（负值），n * 单帧宽尺寸 */
    background-position: -800px 0;
  }
}
```

:::

第二种：通过 `transform: translateX()` 移动，这样可以更好的利用 GPU 加速，且便于缩放（推荐）

:::demo

```html
<div class="viewport">
  <img src="./逐帧动画-loading.png" alt="" />
</div>
```

```css
.viewport {
  /* 设置为单帧的尺寸 */
	width: 100px;
  height: 100px;
  overflow: hidden;
  
  img {
    height: 100%;
    animation: move-strip 1s steps(8) infinite;
  }
}

@keyframes move-strip {
  to {
    transform: translateX(-100%);
  }
}
```

:::

## 块的逐帧动画

有时候，多个相似块之间的 transoform 动画切换，比补间动画的效果要好

如以下的loading补间动画，因为块和块之间需要浏览器补充过渡帧，所以会有残影

```css
animation: rotate 2s linear infinite;
```

:::dom

```vue
<template>
  <div class="container">
    <div v-for="i in 24" :key="i" class="circle" :style="`--i:${i}`"></div>
  </div>
</template>

<style scoped>
@keyframes rotate {
  0% {
    transform: rotate(0);
  }

  100% {
    transform: rotate(360deg);
  }
}

.container {
  position: relative;
  width: 0;
  height: 0;
  padding: 180px;
  animation: rotate 2s linear infinite;
}

.circle {
  --size: calc(15px * (var(--i) / 24));
  position: absolute;
  left: 50%;
  top: 50%;
  width: var(--size);
  height: var(--size);
  border-radius: 50%;
  margin-left: calc(var(--size) / -2);
  margin-top: calc(var(--size) / -2);
  transform: rotate(calc(360deg / 24 * var(--i))) translate(150px);
  background-color: hsl(calc(360deg / 24 * var(--i)), 70%, 60%);
}
</style>
```

:::

但这种情况，多个点之间的位置直接切换，可以出现不带残影的效果，有时候会更好

```css
animation: rotate 1s steps(24) infinite;
```

:::demo

```vue
<template>
  <div class="container">
    <div v-for="i in 24" :key="i" class="circle" :style="`--i:${i}`"></div>
  </div>
</template>

<style scoped>
@keyframes rotate {
  0% {
    transform: rotate(0);
  }

  100% {
    transform: rotate(360deg);
  }
}

.container {
  position: relative;
  width: 0;
  height: 0;
  padding: 180px;
  /* 因为有24个点，所以使用逐帧动画，且设置为24步 */
  animation: rotate 1s steps(24) infinite;
}

.circle {
  --size: calc(15px * (var(--i) / 24));
  position: absolute;
  left: 50%;
  top: 50%;
  width: var(--size);
  height: var(--size);
  border-radius: 50%;
  margin-left: calc(var(--size) / -2);
  margin-top: calc(var(--size) / -2);
  transform: rotate(calc(360deg / 24 * var(--i))) translate(150px);
  background-color: hsl(calc(360deg / 24 * var(--i)), 70%, 60%);
}
</style>
```

:::

> 如其他棋盘的多个不同透明度方块之间的位移切换，也许使用逐帧动画的效果会更好
