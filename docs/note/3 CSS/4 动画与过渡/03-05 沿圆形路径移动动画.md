# 沿圆形路径移动动画

## 父容器旋转，子元素反向旋转

1. 直接绕着一个圆的中心旋转（但内容自身也会旋转，这样会影响可读性）
2. 为了让自身不旋转，在外面再套一层 **div**，**div** 自身环绕大圆选装，元素自身反向旋转，**用内层的变形来抵消外层的变形效果**

:::demo

```html
<div class="round">
  <div class="container">
    <div class="self">K</div>
  </div>
</div>
```

```css
@keyframes spin {
  to { transform: rotate(1turn); }
}

.container {
  /* 大圆半径为 150px */
  transform-origin: 50% 150px;
  animation: spin 3s linear infinite;

  .self {
    animation: inherit; /* 使用继承，复用性更高 */
    animation-direction: reverse; /* 反向抵消 */
  }
}

.round {
  position: relative;
  width: 300px;
  height: 300px;
  border-radius: 50%;
  background: rgb(97, 135, 167);

  .container {
    /* 移动到x轴居中，y轴在最顶端的位置 */
    position: absolute;
    top: 0;
    left: calc(50% - 10px);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: pink;
    color: #000;
    text-align: center;
  }
}
```

:::

> 缺点：需要额外包裹一层dom元素

## CSS Motion Path (`offset-*`)

通过定义 Path 定义一个路径，让元素沿着该路径运动

:::demo

```html
<div class="round">
  <div class="self">K</div>
</div>
```

```css
.round {
  position: relative;
  width: 300px;
  height: 300px;
  border-radius: 50%;
  background: rgb(97, 135, 167);
}

.self {
  /* 元素定位设置为绝对定位 */
  position: absolute;
  top: 0;
  left: 0;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: pink;
  color: #000;
  text-align: center;
  
  /* 方式一：使用 SVG Path (兼容性好，但语法复杂) */
  /* 公式：M cx,cy-r A r r 0 1 1 cx cy+r A r r 0 1 1 cx cy-r */
  /* 解释：从圆顶(cx, cy-r)开始，画两个半圆回到起点 */
  offset-path: path('M 150 0 A 150 150 0 1 1 150 300 A 150 150 0 1 1 150 0');
  
  /* 方式二：使用 Basic Shape (语法简单，Chrome 116+ 支持) */
  /* 语法：circle(半径 at 圆心坐标) */
  /* offset-path: circle(50% at 50% 50%); */
  
  /* 控制元素在路径上的旋转行为 */
  offset-rotate: 0deg; /* 0deg 表示保持方向不变，即不随路径旋转 */
  
  animation: orbit 4s linear infinite;
}

@keyframes orbit {
  from {
    offset-distance: 0%;
  }
  to {
    offset-distance: 100%;
  }
}
```

:::

### 路径公式总结

#### 1. 简化写法 (推荐，需较新浏览器)
直接使用 CSS 图形函数 `circle()` 或 `rect()` 等。
```css
/* 圆心在容器中心，半径为容器宽度的 50% */
offset-path: circle(50% at 50% 50%);
```

#### 2. SVG Path 通用公式
如果必须使用 `path()`，画圆的通用指令如下：
假设圆心坐标为 `(cx, cy)`，半径为 `r`。

```
M cx (cy - r)
A r r 0 1 1 cx (cy + r)
A r r 0 1 1 cx (cy - r)
```

**解析：**
*   `M cx (cy - r)`: **Move to**，移动到圆的最顶点。
*   `A r r 0 1 1 cx (cy + r)`: **Arc**，画一个半径为 `r` 的半圆，终点在圆的最底点 `(cx, cy+r)`。
*   `A r r 0 1 1 cx (cy - r)`: **Arc**，再画一个半径为 `r` 的半圆，回到起点。

## `@property` + 数学公式

利用极坐标转换公式：
$$
x = r \cdot \cos(\theta)\\
y = r \cdot \sin(\theta)
$$
:::demo

```vue
<template>
  <div class="round">
    <div class="self">K</div>
  </div>
</template>

<style>
/* 1. 定义强类型的角度变量 */
@property --angle {
  syntax: '<angle>';
  initial-value: 0deg;
  inherits: false;
}
</style>

<style scoped>
.round {
  position: relative;
  width: 300px;
  height: 300px;
  border-radius: 50%;
  background: rgb(97, 135, 167);

  .self {
    position: absolute;
    /* 1. 将元素初始位置设置在父容器中心 */
    top: calc(50% - 10px);
    left: calc(50% - 10px);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: pink;
    color: #000;
    text-align: center;
    
    --radius: 150px;
    /* 2. 使用 translate + 三角函数定位 */
    translate: calc(sin(var(--angle)) * var(--radius)) calc(cos(var(--angle)) * var(--radius) * -1);
    animation: rotate-math 4s linear infinite;
  }
}

@keyframes rotate-math {
  to {
    --angle: 360deg;
  }
}
</style>
```

:::
