# 锚点定位定位

# CSS 锚点定位 (CSS Anchor Positioning) 学习指南

CSS 锚点定位是一项新兴的 Web 标准，旨在解决无需 JavaScript 即可将一个元素（如提示框、菜单）相对于另一个元素（锚点）进行精确布局的难题。

可以使用 [OddBird](https://www.oddbird.net/) 团队为 CSS 锚点定位提供的 Polyfill （[CSS Anchor Positioning Polyfill](https://anchor-polyfill.netlify.app/)）

```html
<script type="module">
  if (!('anchorName' in document.documentElement.style)) {
    import('https://unpkg.com/@oddbird/css-anchor-positioning')
  }
</script>
```

---

## 核心概念

**CSS 锚点定位** 允许绝对定位元素跳过 DOM 结构，直接相对于页面上的任意 **锚点元素** 进行定位。

- **锚点元素 (Anchor Element)**：作为基准的参考元素。
- **锚定元素 (Anchored Element)**：需要定位的元素。

## 核心 API

#### （1）anchor-name：锚点定义

- **功能**：将元素声明为定位基准点
- **语法**：`anchor-name: <dashed-ident>;`（值必须是破折号开头的标识符（dashed-ident））

```css
.anchor {
  anchor-name: --my-anchor; /* 定义锚点名称 */
}
```

#### （2）position-anchor：锚点绑定

- **功能**：建立元素与锚点的定位关系
- **语法**：`position-anchor: <dashed-ident>;`
- **注意**：需配合定位属性（position: fixed/absolute）使用

```css
.tooltip {
  position: absolute;
  position-anchor: --my-anchor; /* 关联到定义的锚点 */
}
```

#### （3）position-area：区域定位

大多数场景，使用 position-area 属性放置锚点定位元素就足够了，如果需要更精细的控制，可以使用该 anchor()函数来实现

- **功能**：基于 3x3 网格模型快速定位元素，简化 `top`/`left` 等定位属性的设置。
- **语法**：`position-area: <vertical> <horizontal>;`
- **说明**：该属性创建一个围绕锚点的 3x3 网格，通过关键字将元素放置在对应区域。
- **常用值**：
  - **物理值**：`top`, `bottom`, `left`, `right`, `center`
  - **逻辑值**：`start`, `end`, `block-start`, `inline-end`
  - **跨越**：`span-all`, `span-top` 等

![](https://cdn.musiblog.com/CSS/%E5%B8%83%E5%B1%80/position-area.webp)

```css
.tooltip {
  position: absolute;
  position-anchor: --my-anchor;

  /* 放置在锚点上方，水平居中 */
  position-area: top center;
}
```

:::demo

```html
<main>
  <div class="anchor">anchor</div>
  <div class="target">target</div>
</main>
```

```css
.anchor {
  anchor-name: --my-anchor;
}
.target {
  position: absolute;
  position-anchor: --my-anchor;
  /* 放置在锚点的右上角 */
  position-area: top right;
}

/* 以下为装饰样式代码 */
main {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 15em;
  aspect-ratio: 1;
}

div {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  width: 5em;
  aspect-ratio: 1;
  font-family: monospace;
  background-color: #ffbd59;
}
.target {
  background-color: #cb6ce6;
}
```

:::

#### （4）anchor()：动态定位

通过这个可以实现更精准的数值定位

- **功能**：根据锚点位置计算坐标
- **语法**：`anchor(<anchor-name>? <anchor-side>)`
- **方位参数**：
  - 垂直：top/center/bottom
  - 水平：left/center/right
  - 组合：top-left/bottom-right 等
  - 百分比：50% 等

```css
.tooltip {
  left: anchor(--my-anchor 50%);
  bottom: anchor(--my-anchor top);
}
/* 效果与上面是等同的 */
.tooltip {
  position-anchor: --my-anchor;
  left: anchor(50%);
  bottom: anchor(top);
}
```

:::demo

```html
<div class="anchor">kingmusi笔记存放站</div>

<div class="tooltip">欢迎</div>
```

```html
<main>
  <div class="anchor">anchor</div>
  <div class="target">target</div>
</main>
```

```css
.anchor {
  anchor-name: --my-anchor;
}
.target {
  position: absolute;
  position-anchor: --my-anchor;
  bottom: calc(anchor(top) + 5px);
  left: anchor(50%);
}

/* 以下为装饰样式代码 */
main {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 15em;
  aspect-ratio: 1;
}

div {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  width: 5em;
  aspect-ratio: 1;
  font-family: monospace;
  background-color: #ffbd59;
}
.target {
  background-color: #cb6ce6;
}
```

:::

#### （5）anchor-size()：尺寸继承

- **功能**：获取锚点元素的尺寸值
- **语法**：`anchor-size(<anchor-name>? <dimension>)`
- **维度参数**：width/height/block/inline

```css
.tooltip {
  /* 继承锚点宽度 */
  width: anchor-size(width);

  /* 最小高度为锚点高度的1.5倍 */
  min-height: calc(anchor-size(height) * 1.5);
}
```

## 锚点定位的候补位置（position-try-fallbacks）

CSS 的 Anchor Positioning 锚点定位支持 **智能边界处理**，在锚点定位中，称之为候补位置

#### `<'position-area'>` 关键字

当使用 `position-area` 进行定位时，可以提供一个可能的选项列表`position-area`，目标会在溢出时尝试这些选项

例子：溢出时，将目标从顶部移动到底部

:::demo

```html
<div class="scroll-wrapper">
  <main>
    <div class="anchor">anchor</div>
    <div class="target">target</div>
  </main>
</div>
```

```css
.scroll-wrapper {
  /* 告诉浏览器，这个是滚动的容器，让target溢出这个容器时，尝试位置切换 */
  position: relative;
}
.anchor {
  anchor-name: --my-anchor;
}
.target {
  position: absolute;
  position-anchor: --my-anchor;
  /* 放置在锚点的上方 */
  position-area: top center;
  /* 溢出时，移动到锚点的下方 */
  position-try-fallbacks: bottom center;
}

/* 以下为装饰样式代码 */
.scroll-wrapper {
  height: 15em;
  overflow: auto;
}

main {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 30em;
}

.anchor,
.target {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  width: 5em;
  aspect-ratio: 1;
  font-family: monospace;
  background-color: #ffbd59;
}
.target {
  background-color: #cb6ce6;
}
```

:::

#### `@position-try`

可以使用 `@position-try` 规则创建自定义位置选项来修改目标元素的位置，它几乎接受所有可以修改元素位置的属性：

- 插入属性 (`top`, `left`, `bottom`, `right`, `inset-block`, `inset-inline`...)
- 边距属性 (`margin`, `margin-block`, `margin-inline`...)
- 尺寸属性 (`width`, `min-width`, `height`, `max-height`, `inline-size`, `block-size`...)
- Self-alignment 属性 (`align-self`, `justify-self`, `place-self`)
- 定位锚点属性 (`position-anchor`, `position-area`)

:::demo

```html
<div class="scroll-wrapper">
  <main>
    <div class="anchor">anchor</div>
    <div class="target">target</div>
  </main>
</div>
```

```css
.scroll-wrapper {
  /* 告诉浏览器，这个是滚动的容器，让target溢出这个容器时，尝试位置切换 */
  position: relative;
}
.anchor {
  anchor-name: --my-anchor;
}
/* 移动到锚点的下方 */
@position-try --custom-bottom {
  /* 这样写有一次智能定位，并且会有过渡效果，但是往后就不会智能定位了，感觉这属性还有问题 */
  bottom: calc(anchor(top) - anchor-size(height) - 5em);
  /* or */
  bottom: unset;
  top: anchor(bottom);
}
.target {
  position: absolute;
  position-anchor: --my-anchor;
  /* 放置在锚点的上方 */
  left: anchor(center);
  bottom: anchor(top);
  translate: -50% 0;
  /* 溢出时，移动到锚点的下方 */
  position-try-fallbacks: --custom-bottom;

  /* 添加过渡动画 */
  transition: bottom 0.3s, translate 0.3s;
}

/* 以下为装饰样式代码 */
.scroll-wrapper {
  height: 15em;
  overflow: auto;
}

main {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 30em;
}

.anchor,
.target {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  width: 5em;
  aspect-ratio: 1;
  font-family: monospace;
  background-color: #ffbd59;
}
.target {
  background-color: #cb6ce6;
}
```

:::

#### `<try-tactic>`

根据指定的尝试策略交换位置来创建一个新的位置选项。它有三个可能的关键字，每个关键字指定要交换哪些值，本质上是将目标从一侧更改为另一侧

![](https://cdn.musiblog.com/CSS/%E5%B8%83%E5%B1%80/try-tactic.webp)

:::demo

```html
<div class="scroll-wrapper">
  <main>
    <div class="anchor">anchor</div>
    <div class="target">target</div>
  </main>
</div>
```

```css
.scroll-wrapper {
  /* 告诉浏览器，这个是滚动的容器，让target溢出这个容器时，尝试位置切换 */
  position: relative;
}
.anchor {
  anchor-name: --my-anchor;
}
.target {
  position: absolute;
  position-anchor: --my-anchor;
  /* 放置在锚点的上方 */
  left: anchor(center);
  bottom: anchor(top);
  translate: -50% 0;
  /* 溢出时，移动到锚点的下方 */
  position-try-fallbacks: flip-block;
}

/* 以下为装饰样式代码 */
.scroll-wrapper {
  height: 15em;
  overflow: auto;
}

main {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 30em;
}

.anchor,
.target {
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  width: 5em;
  aspect-ratio: 1;
  font-family: monospace;
  background-color: #ffbd59;
}
.target {
  background-color: #cb6ce6;
}
```

:::

## 4. 常见使用场景示例

### 场景一：提示弹窗 (Basic Tooltip)

:::demo

```html
<main>
  <button class="btn">Hover Me</button>
  <span class="tooltip">我是提示信息</span>
</main>
```

```css
/* CSS */
.btn {
  anchor-name: --my-btn;
}

.tooltip {
  position: absolute;
  position-anchor: --my-btn;

  /* 水平居中 */
  left: anchor(center);
  translate: -50% 0;

  /* 位于按钮上方，并留出间距 */
  bottom: calc(anchor(top) + 10px);

  /* 一开始透明度为0，hover时修改透明度 */
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}

.btn:hover + .tooltip {
  opacity: 1;
}

/* 装饰代码 */
main {
  display: flex;
  align-items: flex-end;
  height: 60px;
  .btn {
    cursor: pointer;
  }
  .tooltip {
    padding: 4px;
    border: 1px solid #eee;
    border-radius: 6px;
  }
}
```

:::

### 场景二：熔岩灯菜单 (Lava Lamp Menu)

实现导航栏中跟随鼠标移动的“高亮块”效果。

**原理：**

1. 给每个菜单项（`li` 或 `a`）定义不同的 `anchor-name`。
2. 使用一个绝对定位的背景元素（如 `ul::before`）。
3. 通过 `:hover` 或 `:has()` 动态改变背景元素要锚定的目标名称。

:::demo

```html
<ul>
  <li>下</li>
  <li>划</li>
  <li>线</li>
  <li>跟</li>
  <li>随</li>
  <li>动</li>
  <li>画</li>
</ul>
```

```sass
/* 给每一个li设置 --target 名称，并定义为 anchor */
@for $i from 1 to 8 {
  ul:has(li:nth-child(#{$i}):hover) {
    --target: --anchor-#{$i};
  }
  li:nth-child(#{$i}) {
    anchor-name: --anchor-#{$i};
  }
}
/* 高亮块 */
ul {
  &::before {
    position: absolute;
    bottom: 0;
    /* 关键代码 */
    left: anchor(var(--target) left);
    right: anchor(var(--target) right);
    height: 5px;
    background: transparent;
    transition: 0.3s all;
    transform: scaleX(5);
    content: '';
  }
}
/* hover时设置背景颜色，造成出现的效果 */
ul:hover::before {
  background: var(--vp-c-border);
  transform: scaleX(1);
}


/* 装饰代码 */
ul {
  position: relative;
  width: 100%;
  height: 2em;
  margin: 0;
  padding: 0;
  display: flex;
  list-style: none;

  li {
    flex: 1;
    text-align: center;
    height: 100%;
  }
}
```

:::

### 场景三：结合 Popover API 的菜单

锚点定位可以与浏览器原生的 `popover` 属性完美结合，用于制作下拉菜单或上下文菜单。

:::demo

```html
<button id="menu-btn" popovertarget="my-menu">Open Menu</button>
<ul id="my-menu" popover>
  <li>Option 1</li>
  <li>Option 2</li>
</ul>
```

```css
#menu-btn {
  anchor-name: --anchor;
  cursor: pointer;
}
#my-menu {
  position: absolute;
  position-anchor: --anchor;
  top: anchor(bottom); /* 在按钮下方 */
  left: anchor(left); /* 左对齐 */
  min-width: anchor-size(width);
  box-sizing: border-box;
  margin: 0; /* 重置 popover 默认样式 */

  /* 动画过渡 */
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 0.3s, transform 0.3s, overlay 0.3s allow-discrete, display 0.3s allow-discrete;
}
#my-menu:popover-open {
  opacity: 1;
  transform: translateY(0);
}
@starting-style {
  #my-menu:popover-open {
    opacity: 0;
    transform: translateY(-10px);
  }
}
```

:::
